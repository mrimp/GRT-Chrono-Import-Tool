<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronograph ‚Üí GRT Importer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            /* Approximate GRT-like palette */
            --grt-bg: #10141c;
            --grt-panel: #1b2431;
            --grt-panel-soft: #151d28;
            --grt-highlight: #273347;
            --grt-border: #3a4a61;
            --grt-border-soft: #283447;
            --grt-accent: #3c86c7;
            --grt-accent-soft: #295f90;
            --grt-accent-warm: #e0a542;
            --grt-text-soft: #c7d2e5;
            --grt-text-subtle: #9ca9c0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
                Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--grt-bg);
        }

        .bg-grt-panel {
            background-color: var(--grt-panel);
        }

        .bg-grt-panel-soft {
            background-color: var(--grt-panel-soft);
        }

        .bg-grt-highlight {
            background-color: var(--grt-highlight);
        }

        .border-grt-frame {
            border-color: var(--grt-border);
        }

        .border-grt-soft {
            border-color: var(--grt-border-soft);
        }

        .border-grt-accent {
            border-color: var(--grt-accent);
        }

        .text-grt-soft {
            color: var(--grt-text-soft);
        }

        .text-grt-subtle {
            color: var(--grt-text-subtle);
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-6">
    <div class="max-w-5xl mx-auto">
        <!-- Header + new session button -->
        <div class="bg-grt-panel rounded-2xl shadow-2xl p-6 mb-6 border border-grt-frame">
            <div class="flex items-start justify-between gap-4">
                <div>
                    <div class="inline-flex items-center gap-2 mb-2">
                        <span class="inline-flex items-center px-2 py-0.5 rounded-full bg-grt-highlight border border-grt-accent text-[10px] font-semibold tracking-wide uppercase text-grt-soft">
                            Chronograph ‚Üí GRT
                        </span>
                    </div>
                    <h1 class="text-3xl md:text-4xl font-extrabold text-white mb-1">
                        GARMIN / ATHLON ‚Üí GRT Importer
                    </h1>
                    <p class="text-grt-soft text-sm md:text-base">
                        Import chronograph data (Garmin Xero C1 Pro or Athlon Rangecraft Velocity Pro)
                        directly into Gordon's Reloading Tool projects.
                    </p>
                    <p class="text-grt-subtle text-xs mt-2">
                        v.014 ‚Ä¢ XquiziT Arms
                    </p>
                </div>
                <div class="flex flex-col items-end gap-3">
                    <!-- New Session icon button -->
                    <button
                        id="newSessionBtn"
                        class="p-2.5 rounded-full bg-grt-panel-soft hover:bg-grt-highlight text-slate-100 border border-grt-frame shadow-md transition-transform transform hover:-translate-y-0.5 hover:shadow-lg"
                        title="Start new session"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-5 w-5"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                            stroke-width="2"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                d="M4 4v6h6M20 20v-6h-6M5 13a7 7 0 0112.124-4.95L19 9M5 11l1.876-.95"
                            />
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <div id="statusArea"></div>

        <!-- Upload area -->
        <div id="uploadArea" class="space-y-4 md:space-y-5">
            <!-- 1. GRT Base File -->
            <div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame hover:border-grt-accent transition-colors">
                <div class="flex items-start gap-4">
                    <div
                        class="flex-shrink-0 w-10 h-10 md:w-12 md:h-12 bg-grt-highlight rounded-full flex items-center justify-center text-lg md:text-xl font-bold text-grt-soft border border-grt-accent shadow-inner"
                    >
                        1
                    </div>
                    <div class="flex-1">
                        <h3 class="text-lg font-bold text-white mb-1.5">
                            üìÅ Load GRT Base File (Optional)
                        </h3>
                        <p class="text-grt-soft text-xs md:text-sm mb-4">
                            Upload an existing <code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.grtload</code> file with your rifle, ammo, and powder configuration.
                            Your original tabs, projectile, and propellant settings are preserved.
                        </p>
                        <div class="flex flex-wrap items-center gap-3">
                            <input type="file" id="grtBaseInput" accept=".grtload" class="hidden" />
                            <button
                                onclick="document.getElementById('grtBaseInput').click()"
                                id="grtBaseBtn"
                                class="px-4 py-2 bg-grt-panel-soft hover:bg-grt-highlight text-white rounded-lg text-sm font-medium border border-grt-frame shadow-sm transition-colors"
                            >
                                Select .grtload
                            </button>
                            <span id="grtBaseStatus" class="text-emerald-300 text-xs md:text-sm"></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2. Chronograph Files + device + unit selection -->
            <div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame hover:border-grt-accent transition-colors">
                <div class="flex items-start gap-4">
                    <div
                        class="flex-shrink-0 w-10 h-10 md:w-12 md:h-12 bg-grt-highlight rounded-full flex items-center justify-center text-lg md:text-xl font-bold text-grt-soft border border-grt-accent shadow-inner"
                    >
                        2
                    </div>
                    <div class="flex-1">
                        <h3 class="text-lg font-bold text-white mb-1.5">üéØ Load Chronograph Files</h3>
                        <p class="text-grt-soft text-xs md:text-sm mb-4">
                            Load chronograph data as CSV or Excel files
                            (<code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.csv</code>,
                             <code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.xls</code>,
                             <code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.xlsx</code>),
                            then choose the device and unit before loading files.
                        </p>

                        <!-- Device + unit selection -->
                        <div class="flex flex-col gap-2 mb-4">
                            <div class="flex flex-wrap items-center gap-2">
                                <label for="deviceSelect" class="text-grt-soft text-xs md:text-sm font-semibold">
                                    Chronograph:
                                </label>
                                <select
                                    id="deviceSelect"
                                    class="px-2.5 py-1.5 rounded-lg bg-grt-panel-soft text-white text-xs md:text-sm border border-grt-frame focus:outline-none focus:ring-2 focus:ring-[var(--grt-accent)] focus:border-[var(--grt-accent)]"
                                >
                                    <option value="garmin">Garmin Xero C1 Pro</option>
                                    <option value="athlon">Athlon Rangecraft Velocity Pro</option>
                                </select>
                            </div>
                            <div class="flex flex-wrap items-center gap-2">
                                <label for="unitSelect" class="text-grt-soft text-xs md:text-sm font-semibold">
                                    Velocity unit in file:
                                </label>
                                <select
                                    id="unitSelect"
                                    class="px-2.5 py-1.5 rounded-lg bg-grt-panel-soft text-white text-xs md:text-sm border border-grt-frame focus:outline-none focus:ring-2 focus:ring-[var(--grt-accent)] focus:border-[var(--grt-accent)]"
                                >
                                    <option value="imperial">Imperial (ft/s)</option>
                                    <option value="metric">Metric (m/s)</option>
                                </select>
                                <span class="text-grt-subtle text-[11px] md:text-xs">
                                    GRT always receives m/s; we convert if needed.
                                </span>
                            </div>
                        </div>

                        <div class="flex flex-wrap items-center gap-3">
                            <input
                                type="file"
                                id="garminInput"
                                accept=".csv,.xls,.xlsx"
                                multiple
                                class="hidden"
                            />
                            <button
                                onclick="document.getElementById('garminInput').click()"
                                class="px-5 py-2.5 bg-[var(--grt-accent)] hover:bg-[var(--grt-accent-soft)] text-white rounded-lg text-sm font-semibold shadow-md border border-grt-accent transition-transform transform hover:-translate-y-0.5 hover:shadow-lg"
                            >
                                Select Chronograph Files
                            </button>
                            <span class="text-grt-subtle text-[11px] md:text-xs">
                                You can load multiple strings at once; each file becomes a charge.
                            </span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Feature list -->
            <div class="bg-grt-panel-soft rounded-2xl border border-grt-frame p-4 md:p-5">
                <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
                    <div>
                        <h4 class="text-white font-semibold mb-1.5 text-sm md:text-base">üí° What this tool does</h4>
                        <p class="text-grt-soft text-xs md:text-sm">
                            Converts chronograph strings (Garmin Xero C1 Pro or Athlon Rangecraft Velocity Pro)
                            into a GRT measurement tab, preserving your base project and annotating each charge with original stats.
                        </p>
                    </div>
                    <!-- Left-aligned checklist -->
                    <ul class="text-[var(--grt-text-soft)] text-xs md:text-sm space-y-0.5">
                        <li>‚úÖ Excel / CSV input</li>
                        <li>‚úÖ Robust header / column detection</li>
                        <li>‚úÖ Garmin + Athlon support</li>
                        <li>‚úÖ Manual metric / imperial selection (remembered)</li>
                        <li>‚úÖ GRT velocities in m/s</li>
                        <li>‚úÖ Notes: AVG-E / SD / ES / MIN / MAX / UNIT</li>
                        <li>‚úÖ Charge weight from base <code class="text-[11px] bg-[var(--grt-highlight)] px-1 rounded">mc</code></li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Results -->
        <div id="resultsArea" class="hidden space-y-5 md:space-y-6 mt-4">
            <div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame">
                <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-4">
                    <h2 class="text-xl font-bold text-white">
                        üìä Files Processed: <span id="fileCount">0</span>
                    </h2>
                    <div class="flex flex-wrap items-center gap-2">
                        <span class="text-grt-subtle text-xs md:text-sm">
                            Processed as:
                        </span>
                        <span
                            id="resultsUnit"
                            class="inline-flex items-center px-2.5 py-1 rounded-full text-[11px] md:text-xs font-semibold bg-grt-highlight text-grt-soft border border-grt-frame"
                        >
                            &nbsp;
                        </span>
                    </div>
                </div>
                <div
                    id="statsGrid"
                    class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
                ></div>
            </div>

            <div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame">
                <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-4">
                    <h2 class="text-xl font-bold text-white flex items-center gap-2">
                        üìÑ GRT File (.grtload)
                    </h2>
                    <button
                        onclick="downloadGRT()"
                        class="px-5 py-2.5 bg-emerald-600 hover:bg-emerald-500 text-white rounded-lg text-sm font-semibold shadow-md border border-emerald-500/80 transition-transform transform hover:-translate-y-0.5 hover:shadow-lg"
                    >
                        Download .grtload
                    </button>
                </div>
                <div class="bg-emerald-950/70 border border-emerald-700/70 rounded-xl p-4">
                    <h3 class="text-white font-semibold mb-2 text-sm md:text-base">‚úÖ How to use in GRT</h3>
                    <ol class="text-emerald-200 text-xs md:text-sm space-y-1.5 list-decimal list-inside">
                        <li>Download the generated <code class="bg-emerald-900/70 px-1 rounded text-[11px]">.grtload</code> file.</li>
                        <li>Open GRT and go to <strong>File ‚Üí Open</strong>.</li>
                        <li>Your original tabs remain; a new tab appears: <em>&quot;Garmin Xero C1 Pro Import&quot;</em>.</li>
                        <li>Each chronograph file becomes a separate charge in that measurement.</li>
                        <li>Review the Notes field for AVG-E / SD / ES / MIN / MAX and UNIT from the chronograph.</li>
                    </ol>
                </div>
            </div>
        </div>

        <div class="mt-6 text-center text-grt-subtle text-[11px] md:text-xs">
            <p>‚úÖ Excel/CSV Support ‚Ä¢ ‚úÖ Correct Decimals ‚Ä¢ ‚úÖ Original Statistics Preserved ‚Ä¢ ‚úÖ Multiple Files ‚Ä¢ ‚úÖ Base GRT Configuration Intact</p>
        </div>

        <!-- More visible footer badge -->
        <div class="mt-4 mb-2 flex justify-center">
            <div class="inline-flex items-center gap-2 px-4 py-1.5 rounded-full bg-grt-highlight border border-grt-accent shadow-lg">
                <span class="h-1.5 w-1.5 rounded-full bg-emerald-400 animate-pulse"></span>
                <span class="text-[11px] md:text-xs text-grt-soft tracking-wide uppercase">
                    Made for GRT group
                </span>
            </div>
        </div>
    </div>

    <script>
        // ----------------------
        // Configuration / state
        // ----------------------

        const VELOCITY_MIN = 200;
        const VELOCITY_MAX = 5000;
        const HEADER_SCAN_ROWS = 15;
        const CSV_HEADER_SCAN_LINES = 8;
        const HEADER_PATTERNS = [
            'velocity',
            'velocit',
            'vel',
            'm/s',
            'ft/s',
            'fps',
            'mps'
        ];

        let grtBaseContent = null;
        let outputXML = '';
        let allStats = [];

        // user-selected: how we interpret chronograph values
        let unit = 'imperial';       // 'imperial' (ft/s) or 'metric' (m/s)
        let chronographType = 'garmin'; // 'garmin' or 'athlon'

        // mc from base propellant, in grams (used for minimal GRT and per-charge value)
        let defaultMcValue = '0.002';

        // ----------------------
        // Utility functions
        // ----------------------

        function unitLabel() {
            return unit === 'imperial' ? 'ft/s' : 'm/s';
        }

        function fpsToMps(v) {
            return v / 3.28084;
        }

        function parseNumber(value) {
            if (value === undefined || value === null) return NaN;
            return parseFloat(String(value).replace(',', '.'));
        }

        function isValidNumber(value) {
            return typeof value === 'number' && !isNaN(value);
        }

        function computeStats(velocities) {
            if (!velocities.length) {
                throw new Error('No valid velocity data found');
            }

            const count = velocities.length;
            const mean = velocities.reduce((a, b) => a + b, 0) / count;
            const variance =
                velocities.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / count;
            const sd = Math.sqrt(variance);
            const min = Math.min(...velocities);
            const max = Math.max(...velocities);
            const es = max - min;

            return { count, mean, sd, min, max, es };
        }

        function showStatus(type, message) {
            const area = document.getElementById('statusArea');
            const colors = {
                loading: 'bg-blue-950/80 border-blue-700 text-blue-100',
                error: 'bg-red-950/85 border-red-700 text-red-100',
                success: 'bg-emerald-950/80 border-emerald-700 text-emerald-100'
            };
            const icons = {
                loading: '‚è≥',
                error: '‚ö†Ô∏è',
                success: '‚úÖ'
            };
            area.innerHTML = `
                <div class="status-box ${type} ${colors[type]} border rounded-xl p-4 mb-5 shadow-md flex items-start gap-3 text-sm">
                    <div class="text-lg leading-none pt-0.5">${icons[type] || ''}</div>
                    <div>${message}</div>
                </div>
            `;
        }

        function resetSession() {
            grtBaseContent = null;
            outputXML = '';
            allStats = [];
            defaultMcValue = '0.002';

            // Reset UI
            document.getElementById('uploadArea').classList.remove('hidden');
            document.getElementById('resultsArea').classList.add('hidden');
            document.getElementById('statusArea').innerHTML = '';
            document.getElementById('fileCount').textContent = '0';
            document.getElementById('statsGrid').innerHTML = '';
            document.getElementById('resultsUnit').textContent = '';

            // Reset selects but keep persisted values
            const unitSelect = document.getElementById('unitSelect');
            const deviceSelect = document.getElementById('deviceSelect');

            let savedUnit = null;
            let savedDevice = null;
            try {
                savedUnit = localStorage.getItem('xqa_unit');
                savedDevice = localStorage.getItem('xqa_device');
            } catch (e) {}

            if (savedUnit === 'metric' || savedUnit === 'imperial') {
                unit = savedUnit;
            } else {
                unit = 'imperial';
            }
            if (unitSelect) unitSelect.value = unit;

            if (savedDevice === 'garmin' || savedDevice === 'athlon') {
                chronographType = savedDevice;
            } else {
                chronographType = 'garmin';
            }
            if (deviceSelect) deviceSelect.value = chronographType;

            // Reset base file UI
            const grtBaseBtn = document.getElementById('grtBaseBtn');
            const grtBaseStatus = document.getElementById('grtBaseStatus');
            const grtBaseInput = document.getElementById('grtBaseInput');
            if (grtBaseBtn) {
                grtBaseBtn.className =
                    'px-4 py-2 bg-grt-panel-soft hover:bg-grt-highlight text-white rounded-lg text-sm font-medium border border-grt-frame shadow-sm transition-colors';
            }
            if (grtBaseStatus) grtBaseStatus.textContent = '';
            if (grtBaseInput) grtBaseInput.value = '';

            // Reset chronograph file input
            const garminInput = document.getElementById('garminInput');
            if (garminInput) garminInput.value = '';

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Extract default mc (propellant mass) from base .grtload (grams)
        function extractDefaultMcValue() {
            defaultMcValue = '0.002';

            if (!grtBaseContent) return;

            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(grtBaseContent, 'application/xml');

                // Global propellant mass in base file (grams)
                const globalMcInput = xmlDoc.querySelector('propellant input[name="mc"]');
                if (globalMcInput) {
                    const val = globalMcInput.getAttribute('value') || '';
                    if (val) {
                        defaultMcValue = val;
                    }
                }
            } catch (err) {
                console.error('Error parsing mc from base .grtload:', err);
            }
        }

        // ----------------------
        // Event handlers
        // ----------------------

        // Unit select + persistence
        (function initUnitSelect() {
            const unitSelect = document.getElementById('unitSelect');
            if (!unitSelect) return;

            let savedUnit = null;
            try {
                savedUnit = localStorage.getItem('xqa_unit');
            } catch (e) {}

            if (savedUnit === 'metric' || savedUnit === 'imperial') {
                unit = savedUnit;
                unitSelect.value = savedUnit;
            } else {
                unit = 'imperial';
                unitSelect.value = 'imperial';
            }

            unitSelect.addEventListener('change', (e) => {
                unit = e.target.value;
                try {
                    localStorage.setItem('xqa_unit', unit);
                } catch (err) {}
            });
        })();

        // Device select + persistence
        (function initDeviceSelect() {
            const deviceSelect = document.getElementById('deviceSelect');
            if (!deviceSelect) return;

            let savedDevice = null;
            try {
                savedDevice = localStorage.getItem('xqa_device');
            } catch (e) {}

            if (savedDevice === 'garmin' || savedDevice === 'athlon') {
                chronographType = savedDevice;
                deviceSelect.value = savedDevice;
            } else {
                chronographType = 'garmin';
                deviceSelect.value = 'garmin';
            }

            deviceSelect.addEventListener('change', (e) => {
                chronographType = e.target.value;
                try {
                    localStorage.setItem('xqa_device', chronographType);
                } catch (err) {}
            });
        })();

        document.getElementById('newSessionBtn').addEventListener('click', resetSession);

        document.getElementById('grtBaseInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (ev) => {
                grtBaseContent = ev.target.result;
                const statusEl = document.getElementById('grtBaseStatus');
                const btnEl = document.getElementById('grtBaseBtn');
                if (statusEl) statusEl.textContent = '‚úì ' + file.name;
                if (btnEl) {
                    btnEl.className =
                        'px-4 py-2 bg-green-700 hover:bg-green-600 text-white rounded-lg text-sm font-medium border border-green-500 shadow-sm transition-colors';
                }

                // Once we have base content, pull out default mc
                extractDefaultMcValue();
            };
            reader.readAsText(file);
        });

        document.getElementById('garminInput').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            showStatus('loading', 'Processing chronograph files and computing statistics‚Ä¶');
            allStats = [];
            let filesProcessed = 0;

            files.forEach((file) => {
                const isExcel = file.name.endsWith('.xls') || file.name.endsWith('.xlsx');
                const reader = new FileReader();

                reader.onload = (ev) => {
                    try {
                        let stats;
                        if (isExcel) {
                            if (chronographType === 'athlon') {
                                stats = processAthlonExcel(ev.target.result);
                            } else {
                                stats = processExcel(ev.target.result);
                            }
                        } else {
                            // CSV path (shared logic ‚Äì mainly Garmin-style; Athlon CSV
                            // may or may not match, but we at least try)
                            stats = processCSV(ev.target.result);
                        }

                        allStats.push({ stats, filename: file.name });
                        filesProcessed++;

                        if (filesProcessed === files.length) {
                            generateOutput();
                            showResults();
                            showStatus('success', 'All files processed and added to the GRT measurement.');
                        }
                    } catch (err) {
                        showStatus(
                            'error',
                            'Error in file ' + file.name + ': ' + err.message
                        );
                    }
                };

                if (isExcel) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            });
        });

        // ----------------------
        // Excel processing (Garmin-style)
        // ----------------------

        function processExcel(arrayBuffer) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(firstSheet, {
                header: 1,
                raw: false,
                defval: ''
            });

            if (!rows || rows.length === 0) {
                throw new Error('Empty or unreadable sheet');
            }

            let headerRowIndex = -1;
            let velocityColIndex = 1; // Prefer column B

            // Try to find a labeled header row
            outer: for (let i = 0; i < Math.min(HEADER_SCAN_ROWS, rows.length); i++) {
                const row = rows[i];
                if (!row) continue;

                for (let c = 0; c < row.length; c++) {
                    const cell = String(row[c] || '').toLowerCase();
                    if (HEADER_PATTERNS.some((p) => cell.includes(p))) {
                        headerRowIndex = i;
                        velocityColIndex = c;
                        break outer;
                    }
                }
            }

            // Fallback: assume velocities are in column B
            if (headerRowIndex === -1) {
                velocityColIndex = 1;
                let firstNumericRow = -1;

                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (!row) continue;

                    const num = parseNumber(row[1]);
                    if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                        firstNumericRow = i;
                        break;
                    }
                }

                if (firstNumericRow === -1) {
                    throw new Error('No valid velocity data found in column B');
                }

                headerRowIndex = Math.max(0, firstNumericRow - 1);
            }

            const velocities = [];
            const garminStats = {
                avg: null,
                sd: null,
                es: null,
                min: null,
                max: null,
                powerFactorAvg: null,
                energyAvg: null
            };

            for (let i = headerRowIndex + 1; i < rows.length; i++) {
                const row = rows[i];
                if (!row) continue;

                const label = String(row[0] || '').toLowerCase().trim();
                const valueCell = row[velocityColIndex];
                const num = parseNumber(valueCell);

                // Summary stats rows
                if (label.includes('avg') || label.includes('average') || label.includes('mean')) {
                    garminStats.avg = num;
                    continue;
                }
                if (label.includes('sd') || label.includes('standard deviation')) {
                    garminStats.sd = num;
                    continue;
                }
                if (label.includes('es') || label.includes('extreme spread')) {
                    garminStats.es = num;
                    continue;
                }
                if (label.includes('min') && !label.includes('admin')) {
                    garminStats.min = num;
                    continue;
                }
                if (label.includes('max') && !label.includes('maxi')) {
                    garminStats.max = num;
                    continue;
                }
                if (label.includes('power factor')) {
                    garminStats.powerFactorAvg = String(valueCell || '').trim();
                    continue;
                }
                if (label.includes('energy')) {
                    garminStats.energyAvg = String(valueCell || '').trim();
                    continue;
                }

                // Shot velocities
                if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                    velocities.push(num);
                }
            }

            const stats = computeStats(velocities);

            // Fill in missing OR invalid summary stats from computed stats
            if (!isValidNumber(garminStats.avg)) garminStats.avg = stats.mean;
            if (!isValidNumber(garminStats.sd)) garminStats.sd = stats.sd;
            if (!isValidNumber(garminStats.es)) garminStats.es = stats.es;
            if (!isValidNumber(garminStats.min)) garminStats.min = stats.min;
            if (!isValidNumber(garminStats.max)) garminStats.max = stats.max;

            return {
                ...stats,
                velocities,
                garminStats
            };
        }

        // ----------------------
        // Excel processing (Athlon Rangecraft Velocity Pro)
        // ----------------------

        function processAthlonExcel(arrayBuffer) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(firstSheet, {
                header: 1,
                raw: false,
                defval: ''
            });

            if (!rows || rows.length === 0) {
                throw new Error('Empty or unreadable Athlon sheet');
            }

            // Find shot table header row with "SHOT #" and "SPEED"
            let headerRowIndex = -1;
            let speedColIndex = -1;

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i] || [];
                const lower = row.map(v => String(v || '').trim().toLowerCase());
                if (
                    lower[0].includes('shot #') &&
                    lower.some(c => c.includes('speed'))
                ) {
                    headerRowIndex = i;
                    speedColIndex = lower.findIndex(c => c.includes('speed'));
                    break;
                }
            }

            if (headerRowIndex === -1 || speedColIndex === -1) {
                throw new Error('Could not locate Athlon shot table header');
            }

            // Collect shot velocities below header
            const velocities = [];
            for (let i = headerRowIndex + 1; i < rows.length; i++) {
                const row = rows[i] || [];
                const first = String(row[0] || '').trim();
                if (!first) break;
                const shotNum = parseFloat(first.replace(',', '.'));
                if (isNaN(shotNum)) break;

                const cell = row[speedColIndex];
                const v = parseNumber(cell);
                if (!isNaN(v) && v > VELOCITY_MIN && v < VELOCITY_MAX) {
                    velocities.push(v);
                }
            }

            if (!velocities.length) {
                throw new Error('No valid Athlon velocity data found');
            }

            // Parse summary stats section (Average velocity, Min, Max, SD, ES, Power Factor, KE)
            const garminStats = {
                avg: null,
                sd: null,
                es: null,
                min: null,
                max: null,
                powerFactorAvg: null,
                energyAvg: null
            };

            function numFromText(text) {
                const cleaned = String(text || '')
                    .replace(/[^0-9,.\-]/g, '')
                    .replace(',', '.');
                const num = parseFloat(cleaned);
                return isNaN(num) ? null : num;
            }

            rows.forEach(row => {
                row = row || [];
                const label = String(row[0] || '').trim().toLowerCase();
                const val = row.length > 1 ? row[1] : '';

                if (!label) return;

                if (label.startsWith('average velocity')) {
                    garminStats.avg = numFromText(val);
                } else if (label.startsWith('minimum velocity')) {
                    garminStats.min = numFromText(val);
                } else if (label.startsWith('maximum velocity')) {
                    garminStats.max = numFromText(val);
                } else if (label.startsWith('standard deviation')) {
                    garminStats.sd = numFromText(val);
                } else if (label.startsWith('extreme spread')) {
                    garminStats.es = numFromText(val);
                } else if (label.startsWith('average power factor')) {
                    garminStats.powerFactorAvg = String(val || '').trim();
                } else if (label.startsWith('average kinetic energy')) {
                    garminStats.energyAvg = String(val || '').trim();
                }
            });

            const stats = computeStats(velocities);

            // Fill in missing stats from computed values
            if (!isValidNumber(garminStats.avg)) garminStats.avg = stats.mean;
            if (!isValidNumber(garminStats.sd)) garminStats.sd = stats.sd;
            if (!isValidNumber(garminStats.es)) garminStats.es = stats.es;
            if (!isValidNumber(garminStats.min)) garminStats.min = stats.min;
            if (!isValidNumber(garminStats.max)) garminStats.max = stats.max;

            return {
                ...stats,
                velocities,
                garminStats
            };
        }

        // ----------------------
        // CSV processing (shared)
        // ----------------------

        function processCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (!lines.length) throw new Error('Empty or unreadable CSV');

            const firstLine = lines[0];
            const delimiter = firstLine.includes(';') ? ';' : ',';

            let headerLineIdx = -1;
            let velocityColIndex = 1; // prefer second column (index 1)

            // Try to find header row by scanning first N lines for HEADER_PATTERNS
            outerHeader: for (
                let i = 0;
                i < Math.min(CSV_HEADER_SCAN_LINES, lines.length);
                i++
            ) {
                const parts = lines[i].split(delimiter);
                for (let c = 0; c < parts.length; c++) {
                    const cell = parts[c].toLowerCase();
                    if (HEADER_PATTERNS.some((p) => cell.includes(p))) {
                        headerLineIdx = i;
                        velocityColIndex = c;
                        break outerHeader;
                    }
                }
            }

            // Fallback: assume velocities are in second column (index 1) and infer header row
            if (headerLineIdx === -1) {
                let firstNumericLine = -1;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = line.split(delimiter);
                    if (values.length < 2) continue;

                    const num = parseNumber(values[1]);
                    if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                        firstNumericLine = i;
                        break;
                    }
                }

                if (firstNumericLine === -1) {
                    throw new Error('No valid velocity data found in column 2 of CSV');
                }

                headerLineIdx = Math.max(0, firstNumericLine - 1);
                velocityColIndex = 1;
            }

            const velocities = [];
            const garminStats = {
                avg: null,
                sd: null,
                es: null,
                min: null,
                max: null
            };

            for (let i = headerLineIdx + 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(delimiter);
                if (!values.length) continue;

                const firstCol = values[0] ? values[0].toLowerCase().trim() : '';
                const valueCell = values[velocityColIndex];
                const num = parseNumber(valueCell);

                // Summary stats rows
                if (firstCol.includes('avg') || firstCol.includes('average') || firstCol.includes('mean')) {
                    garminStats.avg = num;
                    continue;
                }
                if (firstCol.includes('sd')) {
                    garminStats.sd = num;
                    continue;
                }
                if (firstCol.includes('es') || firstCol.includes('extreme spread')) {
                    garminStats.es = num;
                    continue;
                }
                if (firstCol.includes('min') && !firstCol.includes('admin')) {
                    garminStats.min = num;
                    continue;
                }
                if (firstCol.includes('max') && !firstCol.includes('maxi')) {
                    garminStats.max = num;
                    continue;
                }

                // Shot velocity
                if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                    velocities.push(num);
                }
            }

            const stats = computeStats(velocities);

            if (!isValidNumber(garminStats.avg)) garminStats.avg = stats.mean;
            if (!isValidNumber(garminStats.sd)) garminStats.sd = stats.sd;
            if (!isValidNumber(garminStats.es)) garminStats.es = stats.es;
            if (!isValidNumber(garminStats.min)) garminStats.min = stats.min;
            if (!isValidNumber(garminStats.max)) garminStats.max = stats.max;

            return {
                ...stats,
                velocities,
                garminStats
            };
        }

        // ----------------------
        // XML generation
        // ----------------------

        function generateOutput() {
            if (grtBaseContent) {
                const appendixOpenTag = '<appendix>';
                const appendixCloseTag = '</appendix>';
                const appendixStart = grtBaseContent.indexOf(appendixOpenTag);
                const appendixEnd = grtBaseContent.indexOf(appendixCloseTag);

                if (appendixStart !== -1 && appendixEnd !== -1) {
                    const beforeAppendixClose = grtBaseContent.substring(0, appendixEnd);
                    const afterAppendixClose = grtBaseContent.substring(appendixEnd);

                    let measurement =
                        '\n      <Measurement index="1" showinreport="true" title="Garmin%20Xero%20C1%20Pro%20Import">\n';

                    allStats.forEach((item, idx) => {
                        measurement += generateChargeXML(item, idx);
                    });

                    measurement += '      </Measurement>';

                    outputXML = beforeAppendixClose + measurement + afterAppendixClose;
                    return;
                }
            }

            // No base content or no appendix found ‚Üí create minimal GRT wrapper
            outputXML = generateMinimalGRT();
        }

        function generateChargeXML(item, idx) {
            const baseName = item.filename.replace(/\.(csv|xls|xlsx)$/i, '');
            const name = baseName.replace(/_/g, '%20');
            const s = item.stats;

            const notes = [];

            // Use only valid numbers in notes
            if (isValidNumber(s.garminStats.avg)) notes.push('AVG-E=' + s.garminStats.avg.toFixed(1));
            if (isValidNumber(s.garminStats.sd))  notes.push('SD='    + s.garminStats.sd.toFixed(1));
            if (isValidNumber(s.garminStats.es))  notes.push('ES='    + s.garminStats.es.toFixed(1));
            if (isValidNumber(s.garminStats.min)) notes.push('MIN='   + s.garminStats.min.toFixed(1));
            if (isValidNumber(s.garminStats.max)) notes.push('MAX='   + s.garminStats.max.toFixed(1));
            if (s.garminStats.powerFactorAvg)
                notes.push('POWER%20FACTOR=' + s.garminStats.powerFactorAvg);
            if (s.garminStats.energyAvg)
                notes.push('ENERGY=' + s.garminStats.energyAvg);

            notes.push('UNIT=' + (unit === 'imperial' ? 'ft/s' : 'm/s'));

            // mc from base is in grams; per-charge "value" is in kg.
            const mcGrams = parseFloat(defaultMcValue) || 0;
            const mcKg = mcGrams / 1000;

            let xml =
                `        <charge name="${name}" showinreport="true" ` +
                `expanded="true" expandedstats="true" note="${notes.join('%20')}" ` +
                `value="${mcKg}" menu="" menuvalue="" menuunit="m" ` +
                `source="Chronograph%20Import">\n`;

            s.velocities.forEach((v) => {
                // Convert to m/s if file velocity is ft/s
                const vInput = v;
                const velocityForXml = unit === 'imperial' ? fpsToMps(vInput) : vInput;
                xml +=
                    `          <shot name="" velocity="${velocityForXml.toFixed(1)}" pressure="0" />\n`;
            });

            xml += '        </charge>\n';
            return xml;
        }

        function generateMinimalGRT() {
            let xml =
                '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>\n' +
                '<GordonsReloadingTool version="2021.2030-NIGHTLY">\n' +
                '  <InnerBallistikInput>\n';

            xml +=
                '    <title>Garmin%20Xero%20C1%20Pro%20Import</title>\n' +
                '    <caliber>\n' +
                '      <input name="CaliberName" value="Generic" />\n' +
                '    </caliber>\n' +
                '    <gun>\n' +
                '      <input name="GunName" value="Generic" />\n' +
                '    </gun>\n' +
                '    <projectile>\n' +
                '      <input name="ProjectileName" value="Generic" />\n' +
                '    </projectile>\n' +
                '    <propellant>\n' +
                `      <input name="mc" value="${defaultMcValue}" unit="g" type="decimal" descr="propellant mass" />\n` +
                '      <input name="pname" value="Generic" />\n' +
                '    </propellant>\n' +
                '    <appendix>\n' +
                '      <Measurement index="1" showinreport="true" title="Garmin%20Xero%20C1%20Pro%20Import">\n';

            allStats.forEach((item, idx) => {
                xml += generateChargeXML(item, idx);
            });

            xml +=
                '      </Measurement>\n' +
                '    </appendix>\n' +
                '  </InnerBallistikInput>\n' +
                '</GordonsReloadingTool>';

            return xml;
        }

        // ----------------------
        // UI rendering
        // ----------------------

        function showResults() {
            document.getElementById('uploadArea').classList.add('hidden');
            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('fileCount').textContent = allStats.length;

            // Show which unit was used
            const resultsUnit = document.getElementById('resultsUnit');
            resultsUnit.textContent = unit === 'imperial' ? 'Imperial (ft/s)' : 'Metric (m/s)';

            const grid = document.getElementById('statsGrid');
            grid.innerHTML = allStats
                .map((item, i) => {
                    const s = item.stats;
                    const preview = (() => {
                        const vs = (s.velocities || []).slice(0, 5);
                        if (!vs.length) return '‚Äî';
                        return vs.map(v => v.toFixed(1)).join(', ') + ' ' + unitLabel();
                    })();
                    return `
                    <div class="bg-grt-panel-soft rounded-xl p-4 border border-grt-frame shadow-sm hover:border-[var(--grt-accent)] hover:shadow-md transition-colors">
                        <h3 class="text-white font-semibold mb-2 text-xs md:text-sm truncate flex items-center gap-1.5">
                            <span class="inline-flex items-center justify-center w-5 h-5 text-[11px] rounded-full bg-grt-highlight text-grt-soft border border-grt-frame">
                                ${i + 1}
                            </span>
                            <span>${item.filename}</span>
                        </h3>
                        <div class="space-y-1.5 text-[11px] md:text-xs">
                            <div class="flex justify-between">
                                <span class="text-grt-soft">Shots</span>
                                <span class="text-white font-semibold">${s.count}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-grt-soft">Average</span>
                                <span class="text-[var(--grt-accent)] font-semibold">
                                    ${s.mean.toFixed(1)} ${unitLabel()}
                                </span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-grt-soft">SD</span>
                                <span class="text-yellow-300 font-semibold">
                                    ${s.sd.toFixed(1)} ${unitLabel()}
                                </span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-grt-soft">ES</span>
                                <span class="text-[var(--grt-accent-warm)] font-semibold">
                                    ${s.es.toFixed(1)} ${unitLabel()}
                                </span>
                            </div>
                            <div class="mt-2 pt-2 border-t border-grt-border flex flex-col gap-0.5">
                                <span class="text-grt-subtle">Sample shots (${unitLabel()}):</span>
                                <span class="text-slate-100 font-mono text-[10px] md:text-[11px]">
                                    ${preview}
                                </span>
                            </div>
                        </div>
                    </div>
                `;
                })
                .join('');
        }

        function downloadGRT() {
            const blob = new Blob([outputXML], {
                type: 'application/xml;charset=utf-8'
            });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const date = new Date().toISOString().split('T')[0].replace(/-/g, '');
            link.href = url;
            link.download = `GRT_Multi_${date}.grtload`;
            link.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
